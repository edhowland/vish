#!/usr/bin/env ruby
# ivs.rb - New and improved interactive Vish shell
# This is an outer REPL.
# An inner REPL would use the loop { read() | eval() | print() }  implementation
# as an interactive .vs script.
require 'readline'

# constants
EOF=0
require_relative 'options'

require_relative '../lib/vish'

options = { 
stdlib: true,
ifiles: []
}
opt = get_options { options }


opt.parse!

# stuff ourself into the remaining args at the first position: E.g. $0
ARGV.unshift(__FILE__)

eval = Evaluator.new
history = History.new

# start up stuff
require_relative 'startup'
ivsrc = File.expand_path '~/.ivsrc'
ivsrc_src = ''
ivsrc_src = File.read(ivsrc) if File.exist?(ivsrc)
startup_code = startup(options) { "prompt='vish> '; _=0;banner='Welcome to Vish" + "version: #{Vish::VERSION}'" + ivsrc_src + "\n" + options[:ifiles].map {|n| File.read(n) }.join() }

begin
  eval.eval startup_code
puts(eval.eval(":banner"))
_=0
loop do
  begin
    BulletinBoard.clear
  prompt = eval.eval(':prompt')
    print prompt
    source=Readline.readline || EOF
    break if source == EOF
    break if source =~ /exit|quit/#
    _ = eval.eval(source) {|i| i.ctx.vars[:_] = _ } unless source.strip.empty?
    #xp _
    p _
  rescue SignalException => err
   # break
rescue Parslet::ParseFailed => err
    puts "Syntax Error: #{err.message}"
  rescue VishRuntimeError => err
    puts "Runtime error: #{err.message}"
  rescue CompileError => err
  puts "Compile error: #{err.message}"
  end
end

rescue EndOfFile
  # nop
end
